---
title: "Detecting dubious shadowing in Go"
date: "2025-04-06T09:49:14-07:00"
summary: "The most common porting bug in the TypeScript Go port"
description: "The most common porting bug in the TypeScript Go port"
tags:
  - go
  - go-analysis
  - typescript-go
cover:
  image: "./ogimage.png"
  relative: true
---

If you hadn't already heard, we're
[porting the TypeScript compiler to Go](https://devblogs.microsoft.com/typescript/typescript-native-port/).
This is a certified Big Deal, no small feat. Language choice is one of those
contentious things, and I'm not going to go into great detail about it here, but
one factor in the language choice is that the ported code is very, very close to
the original TypeScript code.

But obviously Go isn't TypeScript. There are whole classes of bugs that can
happen in Go that won't happen in TypeScript (and vice versa). If you aren't
careful, a direct translation could behave differently, or you could add all new
bugs.

There was one specific kind of bug that came up the most as more and more code
was ported: unintentional shadowing.

## Enter the Shadow Realm

Can you spot the bug?

```go
func (c *Checker) getUnresolvedSymbolForEntityName(name *ast.Node) *ast.Symbol {
    // ...
    result := c.unresolvedSymbols[path]
    if result == nil {
        result := c.newSymbol(ast.SymbolFlagsTypeAlias, text)
        c.unresolvedSymbols[path] = result
        result.Parent = parentSymbol
        c.declaredTypeLinks.Get(result).declaredType = c.unresolvedType
    }
    return result
}
```

The intent here was to return the new symbol, but Go's `:=` operator creates a
new variable within the scope of the if statement's block, so this function
always returns `nil`. `:=` should have been `=`. One character, very hard to
spot.

Seasoned Go devs are probably screaming right now. "_NoOoOoOo why aren't you
using an early return here??_" And they're right! A more idiomatic translation
would be:

```go
func (c *Checker) getUnresolvedSymbolForEntityName(name *ast.Node) *ast.Symbol {
    // ...
    if result := c.unresolvedSymbols[path]; result != nil {
        return result
    }
    result := c.newSymbol(ast.SymbolFlagsTypeAlias, text)
    c.unresolvedSymbols[path] = result
    result.Parent = parentSymbol
    c.declaredTypeLinks.Get(result).declaredType = c.unresolvedType
    return result
}
```

But remember, this is a port. We're not really _trying_ to change the style of
the code all of the time. In fact, the code may have been partially
autogenerated and then copy/pasted. Or just split-screened with the original
code and typed out (i.e., error-prone).

If you look at the original TypeScript code, you'll see what we're trying to
emulate:

```ts
function getUnresolvedSymbolForEntityName(
    name: EntityNameOrEntityNameExpression,
) {
    // ...
    let result = unresolvedSymbols.get(path);
    if (!result) {
        unresolvedSymbols.set(
            path,
            result = createSymbol(SymbolFlags.TypeAlias, text),
        );
        result.parent = parentSymbol;
        result.links.declaredType = unresolvedType;
    }
    return result;
}
```

Should this have been an early return? In my opinion? Yes, absolutely.[^assignment-expression]
Regardless of the language. But, I didn't write this code, it just is what it
is.

[^assignment-expression]: I wouldn't have used an assignment expression either.
    Expressions shouldn't assign things! You cannot convince me otherwise. My
    brain just isn't wired for looking for side effects in the middle of
    something else. Sorry (not sorry).

This bug kept happening over and over during the port; multiple people on the
team complained about it. It's not hard to see why; it becomes muscle memory to
type `:=`, and then it's just one character away from `=` so not too easy to
notice (yourself, or in review). The above example is one of the easier ones to
see visually, but we have other examples too. For example, this kind of code is
all over our type relations code:

```go
switch {
// ...
case source.flags&TypeFlagsIndexedAccess != 0:
    result = r.isRelatedTo(source.objectType, target.objectType)
    if result != TernaryFalse {
        result &= r.isRelatedTo(source.indexType, target.indexType)
        if result != TernaryFalse {
            return result
        }
    }
// ...
}
```

You can imagine maybe that assignment should have been a `:=`.[^early-return] Or
maybe something else is wrong? Hard to say.

[^early-return]: Or maybe you can imagine this code should have been written
    with early returns too. I digress.

## A little `go/analysis` goes a long way

How do we avoid these problems?

As a compiler dev, I only have one solution to every problem: static analysis.

Go has a great static analysis framework called
[`go/analysis`](https://pkg.go.dev/golang.org/x/tools/go/analysis), which is
itself built upon Go's built-in AST and type checking packages (`go/ast`,
`go/types`). With it, we can create our own analyzers to run over our code and
find errors. For convenience, those analyzers can then be compiled into
`golangci-lint` to be run with the rest of the linters.

An `Analyzer` looks like this:

```go
var myAnalyzer = &analysis.Analyzer{
    Name: "myAnalyzer",
    Run: func(pass *analysis.Pass) (any, error) {
        // ...
        pass.Reportf(node.Pos(), "%s is doing a bad thing!", node.Name)
        // ...
    },
}
```

Declare an `Analyzer`, then the `Run` function is given all of the information
about the code being analyzed, report errors (even fixes and related positions,
LSP-style), even return analysis results to be consumed by other passes.

The Go team has actually already created a
[`shadow`](https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/shadow)
analyzer that looks for mistakenly shadowed variables. How does it work?
Consider the following code:

```go
func f() int {
    value := 1
    println(value)
    if condition {
        value := 2
        // ...
        println(value)
    }
    return value
}
```

This code probably has a shadowing bug. The `shadow` pass determines this by
checking every variable to see if there's another variable it could shadow (same
name in a parent scope, with the same type), then checks to see if that
potentially shadowed variable is used "after" the inner declaration, where
"after" is a position check. This avoids false positives like when we don't use
the `outer` value later:

```go
func f() int {
    value := 1
    println(value)
    if condition {
        value := 2
        // ...
        println(value)
    }
    // no use of "value" here!
    // ...
    return someOtherValue
}
```

This method is pretty good and does catch many bugs, but it's not perfect. Take
for example:

```go
func f() int {
    value := 1
    if condition {
        value := 2
        // ...
        println(value)
        return value + 1234
    }
    return value
}
```

Is this a shadowing bug? I'd say it isn't. Nothing we do in the inner scope is
observable in the outer scope since we're returning early. In different words,
no _use_ of the outer scope's `value` is _reachable_ from the shadowing in the
inner scope.

## Going with the (control) flow

Yes, I said it, the magic word, _reachable_. The thing we _want_ to be checking
is whether any assignment to the inner declaration could _reach_ a use of the
outer declaration. This is all just a dataflow analysis question in disguise.[^dom]

[^dom]: There's probably some proper way to describe this in terms of
    "dominators", "dominance frontiers", a "dominator tree", something like
    that. But if I do the math, it's been almost 10 years since I took a
    compiler optimization course, and I can't say I understood the terminology
    back then either. So let's just stick with "reachability".

The existing `shadow` pass approximates reachability using source positions.
This is fast and easy for sure; just look up the scope chain, find what you
might shadow, then check if any use is "after" the shadowing.

But this had enough false positives that I wasn't comfortable enabling it.[^gopls-enabled]
I figured there must be a way to use a proper
[control-flow graph (CFG)](https://en.wikipedia.org/wiki/Control-flow_graph) to
figure this out.

[^gopls-enabled]: I _think_ the Go team would agree;
    [the docs say](https://pkg.go.dev/golang.org/x/tools@v0.31.0/go/analysis/passes/shadow):
    "\[this analyzer\] generates too many false positives and is not yet enabled
    by default".

Fortunately, control-flow graphs are a well established concept and the Go
tooling has ways to get them. The predominant way to do this is to use the
[`go/ssa`](https://pkg.go.dev/golang.org/x/tools/go/ssa) package, which builds a
[static single assignment (SSA)](https://en.wikipedia.org/wiki/Static_single-assignment_form)
representation of the code. I opted _not_ to use it, however. The SSA
representation is pretty fine-grained with its own quirks and (in my opinion)
better suited for more complicated analyses.[^ssa]

Instead, I used [`go/cfg`](https://pkg.go.dev/golang.org/x/tools/go/cfg), which
builds simple control flow graphs out of the AST.

[^ssa]: I found that it modified the structure of the code enough to make it
    difficult to work with for this particular use, doing things like constant
    propagation and simplification. This is definitely great for other
    analyzers, but it seemed a little challenging to use in my case. It's a
    shame; `go/analysis` allows passes to share results, so using `go/ssa` would
    have effectively been "free" via one of the other lint rules we run.
    Thankfully, `go/cfg` is plenty fast and it doesn't seem to have much of an
    impact on our lint time.

Asking for this info is pretty straightforward; just declare that your analyzer
needs it, and then grab its result.

```go
var shadowAnalyzer = &analysis.Analyzer{
    // ...
    Requires: []*analysis.Analyzer{ctrlflow.Analyzer},
    Run: func(pass *analysis.Pass) (any, error) {
        // ...
        cfgs := pass.ResultOf[ctrlflow.Analyzer].(*ctrlflow.CFGs)
        cfg := cfgs.FuncDecl(node)
        // ...
    },
}
```

What does the CFG look like for our previous example? For reference, the code
was:

```go
func f() int {
    value := 1
    if condition {
        value := 2
        // ...
        println(value)
        return value + 1234
    }
    return value
}
```

This produces a CFG that looks like:

{{< rawhtml >}}

<style>
div:nth-child(1 of .goat) > svg > g {
    text[x="16"][y="20"],
    text[x="24"][y="20"],
    text[x="32"][y="20"],
    text[x="40"][y="20"],
    text[x="48"][y="20"] { color: var(--safe-magenta); }
    text[x="280"][y="148"],
    text[x="288"][y="148"],
    text[x="296"][y="148"],
    text[x="304"][y="148"],
    text[x="312"][y="148"] { color: var(--safe-magenta); }
    text[x="16"][y="148"],
    text[x="24"][y="148"],
    text[x="32"][y="148"],
    text[x="40"][y="148"],
    text[x="48"][y="148"] { color: var(--safe-blue); }
    text[x="80"][y="164"],
    text[x="88"][y="164"],
    text[x="96"][y="164"],
    text[x="104"][y="164"],
    text[x="112"][y="164"] { color: var(--safe-blue); }
    text[x="72"][y="180"],
    text[x="80"][y="180"],
    text[x="88"][y="180"],
    text[x="96"][y="180"],
    text[x="104"][y="180"] { color: var(--safe-blue); }
}
</style>

{{< /rawhtml >}}

```goat
+------------+
| value := 1 |
| condition  |
+---+----+---+
    |    |
    |     '-----------------.
    |                        |
    v                        v
+---------------------+   +--------------+
| value := 2          |   | return value |
| println(value)      |   +--------------+
| return value + 1234 |
+---------------------+
```

{{< details summary="Expand to see the above in textual form" >}}

```
.0: # Body@L5
        value := 1
        condition
        succs: 1 2

.1: # IfThen@L7
        value := 2
        println(value)
        return value + 1234

.2: # IfDone@L7
        return value
```

{{< /details >}}

This is exactly what we need! If we start at the inner declaration of `value`,
we can see that it doesn't flow into any use of the outer declaration, so this
code is safe.

Let's try something a little more complicated:

```go
func f() int {
    value := 1
    for i := 0; i < N; i++ {
        value := 2
        // ...
        if i%2 == 0 {
            println("continue!")
            continue
        }
        println(value)
        return value + 1234
    }
    return value
}
```

Is there a shadowing bug here? Let's consult the CFG:

{{< rawhtml >}}

<style>
div:nth-child(2 of .goat) > svg > g {
    text[x="16"][y="20"],
    text[x="24"][y="20"],
    text[x="32"][y="20"],
    text[x="40"][y="20"],
    text[x="48"][y="20"] { color: var(--safe-magenta); }
    text[x="304"][y="20"],
    text[x="312"][y="20"],
    text[x="320"][y="20"],
    text[x="328"][y="20"],
    text[x="336"][y="20"] { color: var(--safe-magenta); }
    text[x="256"][y="84"],
    text[x="264"][y="84"],
    text[x="272"][y="84"],
    text[x="280"][y="84"],
    text[x="288"][y="84"] { color: var(--safe-blue); }
    text[x="248"][y="212"],
    text[x="256"][y="212"],
    text[x="264"][y="212"],
    text[x="272"][y="212"],
    text[x="280"][y="212"] { color: var(--safe-blue); }
    text[x="240"][y="228"],
    text[x="248"][y="228"],
    text[x="256"][y="228"],
    text[x="264"][y="228"],
    text[x="272"][y="228"] { color: var(--safe-blue); }
}
</style>

{{< /rawhtml >}}

```goat
+------------+   +-------+   +--------------+
| value := 1 +-->| i < N +-->| return value |
| i := 0     |   +----+--+   +--------------+
+------------+      ^ |
                    | |       +------------+
   .---------------'   '----->| value := 2 |
  |                           | i%2 == 0   |
  |                           +---+----+---+
  |  +----------------------+     |    |
  |  | println("continue!") |<---'     |
  |  +------+---------------+          |
  |         |                          v
  |         v        +---------------------+
  |      +-----+     | println(value)      |
   '-----+ i++ |     | return value + 1234 |
         +--+--+     +---------------------+
```

{{< details summary="Expand to see the above in textual form" >}}

```
.0: # Body@L5
        value := 1
        i := 0
        succs: 3

.1: # ForBody@L7
        value := 2
        i%2 == 0
        succs: 5 6

.2: # ForDone@L7
        return value

.3: # ForLoop@L7
        i < N
        succs: 1 2

.4: # ForPost@L7
        i++
        succs: 3

.5: # IfThen@L10
        println("continue!")
        succs: 4

.6: # IfDone@L10
        println(value)
        return value + 1234
```

{{< /details >}}

If we follow the control flow from the node containing the inner declaration, we
can see that there _is_ a path to `return value` in the outer scope. If `:=` was
meant to be `=`, the behavior would change; the function would return 2 instead
of 1. So, we say this is a potential shadowing bug, and so that inner variable
would be best renamed.

This CFG-based approach also works nicely for other constructs as well; we can
follow the inner declaration all the way through if statements, loops, switches,
everything; no special casing required.

The only interesting case is function literals. Is there a shadowing bug in this
code?

```go
func f() int {
	value := 1

	callIt(func() {
		value := 2
		println(value)
	})

	return value
}
```

I'd say "maybe", since swapping `:=` to `=` could change the behavior of the
code. The CFG wouldn't exactly show this, since the two functions have different
CFGs entirely. How we choose to relate them is pure choice! It's actually a
pretty similar problem to the infamous
[TypeScript issue 9998](https://github.com/microsoft/TypeScript/issues/9998); do
we consider this code to have executed immediately? Never? Potentially at any
time? I chose to ignore the problem and simply disallow shadowing across
function boundaries, which thankfully didn't have too high of a false-positive
rate to feel bad.

## Enabling the analyzer

With all of this in place, I created a lint rule that we could add to our
`customlint` plugin for `golangci-lint`, which you can see in
[typescript-go PR \#365](https://github.com/microsoft/typescript-go/pull/365).
Surprisingly, this didn't negatively affect lint time. Most of the time, there
isn't shadowing,
[`ast/inspector`](https://pkg.go.dev/golang.org/x/tools/go/ast/inspector) avoids
the need to check a lot of the AST[^ast-inspector], and there are some simple
checks that we can do on top of that.

[^ast-inspector]: This deserves its own post, honestly. In short, the
    [`ast/inspector`](https://pkg.go.dev/golang.org/x/tools/go/ast/inspector)
    package (along with the
    [`inspector`](https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/inspect)
    pass) amortizes the cost of AST walks looking for _specific_ node kinds by
    walking all ASTs once, keeping track of which nodes are present in 32-bit
    bitmasks, which works since Go has fewer than 32 node types. Then you can
    repeatedly ask for certain nodes, and "is this one of the nodes I need" is
    just a bitwise OR. I briefly thought "oh man, can we do this in
    TypeScript?", but then I realized that our AST has _349_ node kinds, way
    more than could fit in a single integer. Drat. It turns out that simple
    languages are in fact faster to analyze (shocker).

The PR only fixed one bug, which is pretty good, but less than I was hoping for;
it turns out that people on the team had already been wasting time debugging to
find these issues, so they were all pretty much fixed already. Thankfully, the
rule seems to be very reliable, and no new shadowing bugs have appeared.

Anyway, hopefully that was an interesting look at one source of potential bugs
in Go (especially for ported code), and how static analysis can help. There are
of course _other_ sources of bugs in Go, and I'm planning to write about how I
was above to catch those too. Stay tuned for that!
